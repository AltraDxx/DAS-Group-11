model_full %>%
summary()
# Remove outliers
q1_aroma <- quantile(Data$aroma, 0.25)
q3_aroma <- quantile(Data$aroma, 0.75)
iqr_aroma <- q3_aroma - q1_aroma
lower_bound_aroma <- q1_aroma - 1.5 * iqr_aroma
upper_bound_aroma <- q3_aroma + 1.5 * iqr_aroma
Data1 <- Data %>%
filter(aroma >= lower_bound_aroma & aroma <= upper_bound_aroma)
q1_flavor <- quantile(Data1$flavor, 0.25)
q3_flavor <- quantile(Data1$flavor, 0.75)
iqr_flavor <- q3_flavor - q1_flavor
lower_bound_flavor <- q1_flavor - 1.5 * iqr_flavor
upper_bound_flavor <- q3_flavor + 1.5 * iqr_flavor
Data1 <- Data1 %>%
filter(flavor >= lower_bound_flavor & flavor <= upper_bound_flavor)
q1_acidity <- quantile(Data1$acidity, 0.25)
q3_acidity <- quantile(Data1$acidity, 0.75)
iqr_acidity <- q3_acidity - q1_acidity
lower_bound_acidity <- q1_acidity - 1.5 * iqr_acidity
upper_bound_acidity <- q3_acidity+ 1.5 * iqr_acidity
Data1 <- Data1 %>%
filter(acidity >= lower_bound_acidity & acidity <= upper_bound_acidity)
q1_defects <- quantile(Data1$category_two_defects, 0.25)
q3_defects <- quantile(Data1$category_two_defects, 0.75)
iqr_defects <- q3_defects - q1_defects
lower_bound_defects <- q1_defects - 1.5 * iqr_defects
upper_bound_defects <- q3_defects + 1.5 * iqr_defects
Data1 <- Data1 %>%
filter(category_two_defects >= lower_bound_defects & category_two_defects <= upper_bound_defects)
q1_altitude <- quantile(Data1$altitude_mean_meters, 0.25)
q3_altitude <- quantile(Data1$altitude_mean_meters, 0.75)
iqr_altitude <- q3_altitude - q1_altitude
lower_bound_altitude <- q1_altitude - 1.5 * iqr_altitude
upper_bound_altitude <- q3_altitude+ 1.5 * iqr_altitude
data <- Data1 %>%
filter(altitude_mean_meters >= lower_bound_altitude & altitude_mean_meters <= upper_bound_altitude)
# Standardize the 'altitude_mean_meters' column
mean_altitude <- mean(data$altitude_mean_meters)
sd_altitude <- sd(data$altitude_mean_meters)
data$altitude_mean_meters <- (data$altitude_mean_meters - mean_altitude) / sd_altitude
# ggpairs of the wrangling data
scatterplot = data %>%
dplyr::select(aroma, flavor, acidity, category_two_defects, altitude_mean_meters, Qualityclass)
ggpairs(scatterplot, aes(color = Qualityclass), title="Scatterplot matrix with ggpairs()")
# Standardize the 'altitude_mean_meters' column
mean_altitude <- mean(data$altitude_mean_meters)
sd_altitude <- sd(data$altitude_mean_meters)
data$altitude_mean_meters <- (data$altitude_mean_meters - mean_altitude) / sd_altitude
#| label: tbl-table1
#| tbl-cap: Summary statistics
# Summary Statistics for 'aroma' and 'flavor' across different quality classes
data |>
summarize('ar.Mean' = mean(aroma),
'ar.Sd' = sd(aroma),
'ar.Min' = min(aroma),
'ar.Max' = max(aroma),
'fl.Mean' = mean(flavor),
'fl.Sd' = sd(flavor),
'fl.Min' = min(flavor),
'fl.Max' = max(flavor),
.by = Qualityclass) |>
gt() |>
fmt_number(decimals = 2) |>
tab_spanner(
label = "aroma",
columns = c(ar.Mean, ar.Sd, ar.Min, ar.Max)
) |>
tab_spanner(
label = "flavor",
columns = c(fl.Mean, fl.Sd, fl.Min, fl.Max)
)
# Summary statistics for 'acidity' and 'category_two_defects' across different quality classes
data |>
summarize('ac.Mean' = mean(acidity),
'ac.Sd' = sd(acidity),
'ac.Min' = min(acidity),
'ac.Max' = max(acidity),
'C.Mean' = mean(category_two_defects),
'C.Sd' = sd(category_two_defects),
'C.Min' = min(category_two_defects),
'C.Max' = max(category_two_defects),
.by = Qualityclass) |>
gt() |>
fmt_number(decimals = 2) |>
tab_spanner(
label = "acidity",
columns = c(ac.Mean, ac.Sd, ac.Min, ac.Max)
) |>
tab_spanner(
label = "Defects",
columns = c(C.Mean, C.Sd, C.Min, C.Max)
)
# Summary statistics for 'altitude_mean_meters' across different quality classes
data |>
summarize('A.Mean' = mean(altitude_mean_meters),
'A.Sd' = sd(altitude_mean_meters),
'A.Min' = min(altitude_mean_meters),
'A.Max' = max(altitude_mean_meters),
.by = Qualityclass) |>
gt() |>
fmt_number(decimals = 2) |>
tab_spanner(
label = "Altitude mean meters",
columns = c(A.Mean, A.Sd, A.Min, A.Max)
)
#| label: tbl-table1
#| tbl-cap: Summary statistics
# Summary Statistics for 'aroma' and 'flavor' across different quality classes
data |>
summarize('ar.Mean' = mean(aroma),
'ar.Sd' = sd(aroma),
'ar.Min' = min(aroma),
'ar.Max' = max(aroma),
'fl.Mean' = mean(flavor),
'fl.Sd' = sd(flavor),
'fl.Min' = min(flavor),
'fl.Max' = max(flavor),
.by = Qualityclass) |>
gt() |>
fmt_number(decimals = 2) |>
tab_spanner(
label = "aroma",
columns = c(ar.Mean, ar.Sd, ar.Min, ar.Max)
) |>
tab_spanner(
label = "flavor",
columns = c(fl.Mean, fl.Sd, fl.Min, fl.Max)
)
# Summary statistics for 'acidity' and 'category_two_defects' across different quality classes
data |>
summarize('ac.Mean' = mean(acidity),
'ac.Sd' = sd(acidity),
'ac.Min' = min(acidity),
'ac.Max' = max(acidity),
'C.Mean' = mean(category_two_defects),
'C.Sd' = sd(category_two_defects),
'C.Min' = min(category_two_defects),
'C.Max' = max(category_two_defects),
.by = Qualityclass) |>
gt() |>
fmt_number(decimals = 2) |>
tab_spanner(
label = "acidity",
columns = c(ac.Mean, ac.Sd, ac.Min, ac.Max)
) |>
tab_spanner(
label = "Defects",
columns = c(C.Mean, C.Sd, C.Min, C.Max)
)
# Summary statistics for 'altitude_mean_meters' across different quality classes
data |>
summarize('A.Mean' = mean(altitude_mean_meters),
'A.Sd' = sd(altitude_mean_meters),
'A.Min' = min(altitude_mean_meters),
'A.Max' = max(altitude_mean_meters),
.by = Qualityclass) |>
gt() |>
fmt_number(decimals = 2) |>
tab_spanner(
label = "Altitude mean meters",
columns = c(A.Mean, A.Sd, A.Min, A.Max)
)
# Calculate the count of coffee bean qualities for each country
quality_counts <- data %>%
group_by(country_of_origin, Qualityclass) %>%
summarise(count = n()) %>%
spread(Qualityclass, count, fill = 0) %>%
mutate(proportion_good = Good / (Good + Poor))
# Create a bar plot showing the proportion of good quality coffee beans by country
ggplot(quality_counts, aes(x = country_of_origin, y = proportion_good, fill = country_of_origin)) +
geom_bar(stat = "identity", show.legend = FALSE) +
labs(x = "Country", y = "Proportion of Good Quality Coffee Beans",
title = "Proportion of Good Quality Coffee Beans by Country") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
# Create a bar plot to visualize the distribution of coffee bean quality by country
counts <- data %>%
group_by(country_of_origin, Qualityclass) %>%
summarise(count = n())
ggplot(data = counts, mapping = aes(x = country_of_origin, y = count, fill = Qualityclass)) +
geom_col() +
labs(x = "Country", y = "counts",
title = "Distribution of coffee bean quality by country")+
coord_flip()
# Create a bar plot showing the proportion of good quality coffee beans by year
quality_counts1 <- data %>%
group_by(harvested, Qualityclass) %>%
summarise(count = n()) %>%
spread(Qualityclass, count, fill = 0) %>%
mutate(proportion_good = Good / (Good + Poor))
ggplot(quality_counts1, aes(x =harvested, y = proportion_good, fill = harvested)) +
geom_bar(stat = "identity",show.legend = FALSE) +
labs(x = "harvested year", y = "Proportion of Good Quality Coffee Beans",
title = "Proportion of Good Quality Coffee Beans by year") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# Create a bar plot to visualize the distribution of coffee bean quality by year
counts1 <- data %>%
group_by(harvested, Qualityclass) %>%
summarise(count = n())
ggplot(data = counts1, mapping = aes(x = harvested, y = count, fill = Qualityclass)) +
geom_col() +
labs(x = "harvested year", y = "Qualityclass",
title = "Distribution of coffee bean quality by year")
model_country_aroma_flavor <- glm(Qualityclass ~ country_of_origin + aroma + flavor, data = data, family = binomial(link = "logit"))
model_country_aroma_flavor
plot_model(model_country_aroma_flavor, type = "pred",
terms = c("aroma", "flavor", "country_of_origin"))
model_country_acidity_altitude <- glm(Qualityclass ~ country_of_origin + acidity + altitude_mean_meters, data = data, family = binomial(link = "logit"))
plot_model(model_country_acidity_altitude, type = "pred",
terms = c("acidity", "altitude_mean_meters", "country_of_origin"))
model_aroma_flavor_acidity <- glm(Qualityclass ~ country_of_origin + aroma + category_two_defects, data = data, family = binomial(link = "logit"))
plot_model(model_aroma_flavor_acidity, type = "pred",
terms = c("category_two_defects", "aroma", "country_of_origin"))
# Select 'country_of_origin' and 'Qualityclass' columns and generate a contingency table.
data_country <- data %>%
dplyr::select(country_of_origin, Qualityclass)
data_country %>%
tabyl(country_of_origin, Qualityclass) %>%
adorn_percentages() %>%
adorn_pct_formatting() %>%
adorn_ns()
# Create a barplot of 'country_of_origin' across different 'Qualityclass' levels
p0 <- ggplot(data_country, aes(x = Qualityclass, y = after_stat(prop), group = country_of_origin, fill = country_of_origin)) +
geom_bar(position = "dodge", stat = "count") +
labs(y = "Proportion")
p0
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
length(unique(data$country_of_origin))
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
length(unique(data$country_of_origin))
length(unique(data_country$country_of_origin))
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
length(unique(data$country_of_origin))
length(unique(data_country$country_of_origin))
if (any(is.na(data))) {
print("数据框中存在缺失值（NA）")
} else {
print("数据框中没有缺失值（NA）")
}
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
length(unique(data$country_of_origin))
length(unique(data_country$country_of_origin))
if (any(is.na(data_country))) {
print("数据框中存在缺失值（NA）")
} else {
print("数据框中没有缺失值（NA）")
}
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
model_country_coef_logodds
confint_logodds <- confint(model_country)
confint_logodds
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
model_country_coef_logodds
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
model_country
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
model_country
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
any(is.na(data))
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
model_country_coef_logodds
confint_logodds <- confint(model_country)
any(is.na(confint_logodds))
confint_logodds
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
any(is.na(model_country_coef_logodds))
confint_logodds <- confint(model_country)
any(is.na(confint_logodds))
confint_logodds
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Fit logistic regression model with 'country_of_origin' predictor and 'Qualityclass' response
model_country <- glm(Qualityclass ~ country_of_origin, data = data_country, family = binomial(link = "logit"))
model_country %>%
summary()
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
confint_logodds <- confint(model_country)
confint_logodds
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
confint_logodds <- confint(model_country)
confint_logodds
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
confint_logodds <- confint(model_country)
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
confint_logodds <- confint(model_country)
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
model_country_coef_odds
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
confint_logodds <- confint(model_country)
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Extract coefficients from the model and calculate their confidence intervals.
model_country_coef_logodds <- model_country %>%
summary() %>%
coef()
confint_logodds <- confint(model_country)
# Plot log-odds of being a good instructor
plot_model(model_country, show.values = TRUE, transform = NULL,
title = "Log-Odds (Good instructor)", show.p = FALSE)
# Transform the coefficients into odds ratios and obtain their confidence intervals
model_country_coef_odds <- model_country %>%
summary() %>%
coef() %>%
exp()
model_country_coef_odds
exp(confint_logodds)
# Plot odds of being a good instructor
plot_model(model_country, show.values = TRUE,
title = "Odds (Good instructor)", show.p = FALSE)
# Cross-validation
# Create 5-fold cross-validation splits
set.seed(123)  # Set seed to ensure reproducible results
folds <- createFolds(data_pca_final$Qualityclass, k = 5)
ctrl <- trainControl(method = "cv", index = folds)
# Train model using cross-validation
model <- train(Qualityclass ~ PC1 + PC2 + country_of_origin + category_two_defects, data = data_pca_final, method = "glm",
family = binomial(link = "logit"),trControl = ctrl)
# View cross-validation results
# Accuracy: The accuracy score of approximately 83.44% suggests that the model correctly predicted the class labels for around 83.44% of the samples on average across all folds. This indicates a reasonably good predictive performance of the model.
# Kappa: The kappa statistic measures the agreement between the predicted and actual class labels, accounting for the possibility of agreement occurring by chance. A kappa value of approximately 0.67 indicates substantial agreement between the predicted and actual class labels beyond what would be expected by chance alone.
# Overall, the results suggest that the GLM model performs well in classifying samples into the 'Poor' and 'Good' classes, with a relatively high accuracy and substantial agreement between predicted and actual class labels.
# Cross-validation
# Create 5-fold cross-validation splits
set.seed(123)  # Set seed to ensure reproducible results
folds <- createFolds(data_pca_final$Qualityclass, k = 5)
ctrl <- trainControl(method = "cv", index = folds)
# Train model using cross-validation
model <- train(Qualityclass ~ PC1 + PC2 + country_of_origin + category_two_defects, data = data_pca_final, method = "glm",
family = binomial(link = "logit"), trControl = ctrl)
# View cross-validation results
print(model)
# Accuracy: The accuracy score of approximately 83.44% suggests that the model correctly predicted the class labels for around 83.44% of the samples on average across all folds. This indicates a reasonably good predictive performance of the model.
# Kappa: The kappa statistic measures the agreement between the predicted and actual class labels, accounting for the possibility of agreement occurring by chance. A kappa value of approximately 0.67 indicates substantial agreement between the predicted and actual class labels beyond what would be expected by chance alone.
# Overall, the results suggest that the GLM model performs well in classifying samples into the 'Poor' and 'Good' classes, with a relatively high accuracy and substantial agreement between predicted and actual class labels.
# Cross-validation
# Create 5-fold cross-validation splits
set.seed(123)  # Set seed to ensure reproducible results
folds <- createFolds(data_pca_final$Qualityclass, k = 5)
ctrl <- trainControl(method = "cv", index = folds)
# Train model using cross-validation
model <- train(Qualityclass ~ PC1 + PC2 + country_of_origin + category_two_defects, data = data_pca_final, method = "glm",
family = binomial(link = "logit"), trControl = ctrl)
# View cross-validation results
model
# Accuracy: The accuracy score of approximately 83.44% suggests that the model correctly predicted the class labels for around 83.44% of the samples on average across all folds. This indicates a reasonably good predictive performance of the model.
# Kappa: The kappa statistic measures the agreement between the predicted and actual class labels, accounting for the possibility of agreement occurring by chance. A kappa value of approximately 0.67 indicates substantial agreement between the predicted and actual class labels beyond what would be expected by chance alone.
# Overall, the results suggest that the GLM model performs well in classifying samples into the 'Poor' and 'Good' classes, with a relatively high accuracy and substantial agreement between predicted and actual class labels.
# Final Logistic Regression Model for Qualityclass Prediction
optimal_model <- glm(Qualityclass ~ PC1 + PC2 + country_of_origin + category_two_defects, family = binomial(link = "logit"), data = data_pca_final)
optimal_model %>%
summary()
optimal_model_summary <- glance(optimal_model)
kable(optimal_model_summary,digits =2)
